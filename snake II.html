<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>Snake</title>
</head>
<body style='background-color:white'>
</body>
<script>
	var snakeGame, kaa, applee;
	
	window.onload = function()
	{
		snakeGame = new SnakeGame(450, 300, 25, 100);
		kaa = new Snake([[2,5],[1,5],[0,5]], 'right');
    applee = new Apple([8,8]);
		snakeGame.init(kaa, applee);
	}
	
	document.addEventListener('keydown', function(e)
	{
		let direction = snakeGame.snake.direction;
		switch(e.key)
		{
			case 'ArrowRight':
				direction = direction === 'left' ? 'left' : 'right';
				break;
			case 'ArrowDown':
				direction = direction === 'up' ? 'up' : 'down';
				break;
			case 'ArrowUp':
				direction = direction === 'down' ? 'down' : 'up';
				break;
			case 'ArrowLeft':
				direction = direction === 'right' ? 'right' : 'left';
				break;
			case ' ':
				kaa = new Snake([[2,5],[1,5],[0,5]], 'right');
        applee = new Apple([8,8]);
				snakeGame.init(kaa, applee);
				return;
		}
		snakeGame.snake.direction = direction;
	})
	
	function SnakeGame(canvasWidth, canvasHeight, blockSize, delay)
	{
		this.canvas = document.createElement('canvas');
		this.ctx = this.canvas.getContext('2d');
		this.blockSize = blockSize;
		this.canvas.width = canvasWidth;
		this.canvas.height = canvasHeight;
		this.canvas.style.border = '1px solid';
		this.canvas.style.margin = '0 auto';
		this.canvas.style.display = 'block';
		this.canvas.style.marginTop = '50vh';
		this.canvas.style.transform =  'translateY(-50%)';
		document.body.appendChild(this.canvas);
		this.delay = delay;
		var instance = this,
				timeout;
		
		var refreshCanvas = function()
		{
			instance.snake.advance();
			if(instance.checkCollision())
				instance.gameOver();
			else
			{
				instance.ctx.clearRect(0, 0, instance.canvas.width, instance.canvas.height);
				instance.snake.draw(instance.ctx, instance.blockSize);
        instance.apple.draw(instance.ctx, instance.blockSize);
				timeout = setTimeout(refreshCanvas, instance.delay);
			}
		};
		
		this.init = function(snake, apple)
		{
			this.snake = snake;
      this.apple = apple;
			snake.draw(this.ctx, this.blockSize);
      apple.draw(this.ctx, this.blockSize);
			clearTimeout(timeout);
			refreshCanvas();
		};
		
		this.gameOver = function()
		{
			this.ctx.save();
			this.ctx.fillSyle = '#000';
			this.ctx.fillText('Game Over', 10, 20);
			this.ctx.fillText('Appuyer sur ESPACE pour rejouer', 10, 35);
			this.ctx.restore();
		}
		
		this.checkCollision = function()
		{
			let body = this.snake.position, 
					headX = this.snake.position[0][0],
					headY = this.snake.position[0][1],
					borderX = this.canvas.width/this.blockSize,
					borderY = this.canvas.height/this.blockSize,
					wallCollision = false,
					selfCollision = false;
	
			if(headX < 0 || headX >= borderX || headY < 0 || headY >= borderY)
				wallCollision = true;
			
			for(let i = 1; i < this.snake.position.length; i++)
				if(headX === body[i][0] && headY === body[i][1])
					selfCollision = true;
			
			return wallCollision || selfCollision;
		};
	}
	
	function Snake(position, direction)
	{
		this.position = position;
		this.direction = direction;
		this.draw = function(ctx, blockSize)
		{
			ctx.save();
			ctx.fillStyle = '#BAC9FE';
			for(let i = 0; i < this.position.length; i++)
				ctx.fillRect((this.position[i][0] * blockSize) - 1, (this.position[i][1] * blockSize) - 1, blockSize, blockSize);
			ctx.restore();
		};
		
		this.advance = function()
		{
			let x = this.position[0][0],
					y = this.position[0][1];
				switch(this.direction)
				{
					case "right":		
						x++;
						break;
					case "left":		
						x--;
						break;
					case "up":		
						y--;
						break;
					case "down":		
						y++;
						break;
					default:
						x++;
				}
			this.position.unshift([x, y]);
			this.position.pop();
		};
	}
  
  function Apple(position)
  {
    this.position = position;
    this.draw = function(ctx, blockSize)
    {
      ctx.save();
      ctx.fillStyle = '#BADA55';
      ctx.beginPath();
      let radius = blockSize/2;
      ctx.arc((this.position[0] * blockSize) + radius, (this.position[1] * blockSize) + radius, radius, 0, 2*Math.PI);
      ctx.fill();
      ctx.restore();
    };
  }
</script>
</html>